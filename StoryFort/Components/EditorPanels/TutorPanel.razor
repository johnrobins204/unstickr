@using StoryFort.Services
@using StoryFort.Models
@using Microsoft.JSInterop
@inject StoryState StoryState
@inject ICohereTutorService CohereService
@inject IHttpClientFactory HttpClientFactory
@inject IJSRuntime JS
@inject TutorOrchestrator TutorOrchestrator
@implements IAsyncDisposable
@using Serilog

<div class="tutor-overlay">
    <!-- Speech Bubble (Visible when NOT expanded, or explicitly shown) -->
    @if (!IsExpanded && !string.IsNullOrEmpty(StoryState.TutorNotes))
    {
        <div class="tutor-bubble">
            <div class="d-flex justify-content-between align-items-center mb-1">
                <small class="fw-bold text-primary">Alice suggestion:</small>
                <button type="button" class="btn-close btn-sm" aria-label="Close" @onclick="DismissTutorNote"></button>
            </div>
            <p class="small mb-1 text-truncate" style="max-width: 200px;">@StoryState.TutorNotes</p>
            <div class="text-end">
                <small class="text-primary" style="cursor: pointer;" @onclick="ToggleExpand">Open Chat</small>
            </div>
        </div>
    }

    <!-- Expanded Chat Window -->
    @if (IsExpanded) 
    {
        <div class="tutor-window">
            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center p-3 rounded-top">
                <div class="d-flex align-items-center gap-2">
                    <i class="bi bi-robot"></i>
                    <h6 class="m-0">Creative Assistant</h6>
                </div>
                <button type="button" class="btn-close btn-close-white" @onclick="ToggleExpand"></button>
            </div>
            
            <div class="card-body overflow-auto p-3 bg-light" style="height: 300px;">
                @if (IsLoadingAI)
                {
                    <div class="d-flex justify-content-center align-items-start pt-4 h-100">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Thinking...</span>
                        </div>
                    </div>
                }
                else
                {
                    <!-- Current State / Notes -->
                     @if (!string.IsNullOrEmpty(StoryState.TutorNotes))
                     {
                        <div class="alert alert-info border-0 shadow-sm">
                            <h6 class="alert-heading h6"><i class="bi bi-lightbulb-fill"></i> Idea:</h6>
                            <p class="mb-0 small" style="white-space: pre-wrap;">@StoryState.TutorNotes</p>
                            <div class="mt-2 text-end">
                                <button class="btn btn-sm btn-outline-info bg-white" @onclick="DismissTutorNote">Clear</button>
                            </div>
                        </div>
                     }
                     else
                     {
                        <!-- Idle States -->
                        <div class="text-center text-muted mt-4">
                            @if (CurrentTutorState == TutorState.Idle)
                            {
                                <i class="bi bi-emoji-smile fs-1 d-block mb-2"></i>
                                <p class="small">I'm reading along with you...</p>
                            }
                            else if (CurrentTutorState == TutorState.LookingUp)
                            {
                                <i class="bi bi-emoji-sunglasses fs-1 d-block mb-2"></i>
                                <p class="small">Deep in thought?</p>
                            }
                            else if (CurrentTutorState == TutorState.OfferingHelp)
                            {
                                <i class="bi bi-stars fs-1 d-block mb-2 text-warning"></i>
                                <p class="small mb-2">Need a spark?</p>
                                <button class="btn btn-sm btn-outline-success" @onclick="async () => { StoryState.TutorNotes = string.Empty; await OnHintClick(); }">
                                    Get a hint
                                </button>
                            }
                        </div>
                     }
                }
            </div>

            <div class="card-footer bg-white border-top p-2">
                <div class="input-group">
                    <textarea class="form-control border-0 bg-light" 
                              @bind="Prompt" 
                              @bind:event="oninput"
                              placeholder="Ask Alice..."
                              style="resize: none; height: 38px;"
                              @onkeydown="@EnterKeyHandler">
                    </textarea>
                    <button class="btn btn-primary" @onclick="AskTutor" disabled="@(IsLoadingAI || string.IsNullOrWhiteSpace(Prompt))">
                        <i class="bi bi-send-fill"></i>
                    </button>
                </div>
            </div>
        </div>
    }

    <!-- Avatar Toggle (Always Visible) -->
    <div class="tutor-avatar" @onclick="ToggleExpand" title="@GetTutorTooltip()">
        <img src="@GetTutorImage()" class="@(IsLoadingAI ? "pulsing" : "")" alt="Tutor Avatar" />
    </div>
</div>

@code {
    [Parameter]
    public Account? CurrentAccount { get; set; }

    private bool IsLoadingAI = false;
    // Default to false for widget
    private bool IsExpanded = false;
    private string Prompt = "";

    // --- Inactivity & Tutor Logic ---
    private enum TutorState { Idle, LookingUp, OfferingHelp }
    private TutorState CurrentTutorState = TutorState.Idle;
    private bool IsGlancingUp = false;
    private DotNetObjectReference<TutorPanel>? objRef;

    private void ToggleExpand() => IsExpanded = !IsExpanded;

    private async Task EnterKeyHandler(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            if (StoryState.TutorSession.CurrentMode == TutorMode.SparkProtocol)
            {
                // Treat input as answer to SparkProtocol
                StoryState.TutorSession.History.Add(Prompt);
                var response = await TutorOrchestrator.RunSparkProtocolAsync();
                StoryState.TutorNotes = response;
                Prompt = "";
                // Check for handoff
                if (StoryState.TutorSession.LastJsonStatus == "READY_TO_WRITE")
                {
                    // Try to extract summary from response
                    string? summary = null;
                    try
                    {
                        var json = System.Text.Json.JsonDocument.Parse(response);
                        if (json.RootElement.TryGetProperty("summary", out var s) && s.ValueKind == System.Text.Json.JsonValueKind.String)
                            summary = s.GetString();
                    }
                    catch { /* Not JSON, ignore */ }

                    // Create a Lore NotebookEntity for the spark idea
                    if (!string.IsNullOrWhiteSpace(summary))
                    {
                        var entry = new NotebookEntity {
                            Name = "Spark Idea",
                            Description = summary
                        };
                        var loreNotebook = StoryState.Notebooks.FirstOrDefault(n => n.Name == "Lore");
                        if (loreNotebook != null)
                        {
                            loreNotebook.Entities.Add(entry);
                        }
                    }

                    StoryState.TutorNotes = "You're ready to start writing!";
                    StoryState.TutorSession.CurrentMode = TutorMode.Idle;
                    StoryState.TutorSession.History.Clear();
                    IsExpanded = false;
                    await JS.InvokeVoidAsync("editorJs.focusEditor");
                }
                StateHasChanged();
            }
            else
            {
                await AskTutor();
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            objRef = DotNetObjectReference.Create(this);
            try 
            {
                await JS.InvokeVoidAsync("inactivityTimer.initialize", objRef);
            }
            catch (Exception)
            {
                // Graceful degradation
            }
        }
    }

    private async Task AskTutor()
    {
        if (string.IsNullOrWhiteSpace(Prompt)) return;

        IsLoadingAI = true;
        // Auto-expand to show loading state if not already
        if (!IsExpanded) IsExpanded = true;
        
        var currentPrompt = Prompt;
        Prompt = ""; // Clear input immediately
        
        try
        {
            var account = CurrentAccount ?? StoryState.Account;
            if (account != null)
            {
                // Note: GetSocraticPromptAsync handles context internally or assumes simple prompt for now.
                // If strict prompting is needed, we would prepend it here, but instruction says "Use GetSocraticPromptAsync(Prompt...)"
                var response = await CohereService.GetSocraticPromptAsync(currentPrompt, account, account.UseReasoningModel);
                StoryState.TutorNotes = response;
            }
            else
            {
                StoryState.TutorNotes = "No account context available.";
            }
        }
        catch (Exception ex)
        {
            Log.Error(ex, "AI Error");
            StoryState.TutorNotes = "I couldn't reach the AI service.";
        }
        finally
        {
            IsLoadingAI = false;
            // Ensure expanded so they see the error or result
            IsExpanded = true;
            StateHasChanged();
        }
    }

    private async Task OnHintClick()
    {
        StoryState.TutorSession.CurrentMode = TutorMode.SparkProtocol;
        var response = await TutorOrchestrator.RunSparkProtocolAsync();
        StoryState.TutorNotes = response;
            // Check for handoff
            if (StoryState.TutorSession.LastJsonStatus == "READY_TO_WRITE")
            {
                string? summary = null;
                try
                {
                    var json = System.Text.Json.JsonDocument.Parse(response);
                    if (json.RootElement.TryGetProperty("summary", out var s) && s.ValueKind == System.Text.Json.JsonValueKind.String)
                        summary = s.GetString();
                }
                catch { /* Not JSON, ignore */ }

                if (!string.IsNullOrWhiteSpace(summary))
                {
                    var entry = new NotebookEntity {
                        Name = "Spark Idea",
                        Description = summary
                    };
                    var loreNotebook = StoryState.Notebooks.FirstOrDefault(n => n.Name == "Lore");
                    if (loreNotebook != null)
                    {
                        loreNotebook.Entities.Add(entry);
                    }
                }

                StoryState.TutorNotes = "You're ready to start writing!";
                StoryState.TutorSession.CurrentMode = TutorMode.Idle;
                StoryState.TutorSession.History.Clear();
                IsExpanded = false;
                await JS.InvokeVoidAsync("editorJs.focusEditor");
            }
            StateHasChanged();
    }

    private async Task RunReview(ReviewType type)
    {
        StoryState.TutorSession.CurrentMode = TutorMode.ReviewMode;
        var response = await TutorOrchestrator.RunReviewProtocolAsync(type);
        StoryState.TutorNotes = response;
        StateHasChanged();
    }

    // --- JS Interop Methods matching inactivity.js ---

    [JSInvokable]
    public void OnInactivityStage1()
    {
        // 15 seconds: Look up
        CurrentTutorState = TutorState.LookingUp;
        IsGlancingUp = true;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnInactivityStage2()
    {
        // 30 seconds: Offer help
        CurrentTutorState = TutorState.OfferingHelp;
        IsGlancingUp = true; // Still looking up
        StateHasChanged();
    }

    [JSInvokable]
    public void OnActivityDetected()
    {
        // When user types, go back to reading
        if (CurrentTutorState != TutorState.Idle) 
        {
            CurrentTutorState = TutorState.Idle;
            IsGlancingUp = false;
            StateHasChanged();
        }
    }

    [JSInvokable]
    public void OnFrustrationDetected()
    {
        // Bypasses timers to offer help immediately
        // Useful for rage clicks or button mashing
        CurrentTutorState = TutorState.OfferingHelp;
        IsGlancingUp = true;
        StateHasChanged();
    }

    private string GetTutorImage()
    {
        // Use actual assets found in wwwroot/images
        if (CurrentTutorState == TutorState.OfferingHelp) return "/images/tutor_help.png";
        if (IsGlancingUp) return "/images/tutor_lookup.png"; 
        return "/images/tutor_reading.png"; 
    }

    private string GetTutorTooltip()
    {
        return IsExpanded ? "Close Chat" : "Ask Alice";
    }

    private void DismissTutorNote()
    {
        StoryState.TutorNotes = string.Empty;
    }

    // Helper
    private string Truncate(string input, int length)
    {
        if (string.IsNullOrEmpty(input) || input.Length <= length) return input;
        return input.Substring(0, length) + "...";
    }

    private class LlamaResponse
    {
        public string response { get; set; } = "";
    }

    public async ValueTask DisposeAsync()
    {
        if (objRef != null)
        {
            try { await JS.InvokeVoidAsync("inactivityTimer.dispose"); } catch {}
            objRef.Dispose();
        }
    }
}

